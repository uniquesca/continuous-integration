name: QA Checks

on:
  workflow_call:
    secrets:
      UNIQUES_GITHUB_ACCESS_TOKEN:
        description: 'Access token for cloning Uniques private repositories from GitHub'
        required: true
    inputs:
      use_db:
        description: 'Whether a database is needed (for example for unit tests)'
        required: false
        default: false
        type: boolean
      db_dump_file:
        description: 'Path to the DB dump file - ignored if `use_db` is not set to `true`'
        required: false
        type: string
      generate_coverage_badge:
        description: 'Whether a unit test coverage badge needs to be generated and committed'
        required: false
        default: true
        type: boolean
      coverage_badge_file:
        description: 'Path to a coverage badge file - ignored if `generate_coverage_badge` is not set to `true`'
        required: false
        default: 'coverage.svg'
        type: string
      exec_bit_check:
        description: 'Whether execution bit check should be performed'
        required: false
        default: false
        type: boolean
      exec_bit_check_paths:
        description: 'Paths to use for checking files for executability, split by comma. Use . (dot) to include 
          root directory. Example: "module, vendor/bin" or "., node_modules"'
        required: false
        default: ''
        type: string
      exec_bit_check_extensions:
        description: 'File extensions to check for executability, split by comma. Example: "sh, php"'
        required: false
        default: 'sh'
        type: string

jobs:
  matrix:
    name: Get CI job matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v3

      - run: sudo apt-get install jq -y

      - name: Get CI configuration from ci.json file
        id: matrix
        run: echo "matrix=$(cat ci.json | jq -c .)" >> $GITHUB_OUTPUT

  qa:
    name: Run QA checks
    needs: [matrix]
    runs-on: ${{ matrix.setup.os }}
    env:
      phpunit_executed: false
    strategy:
      fail-fast: false
      matrix:
        setup: ${{ fromJSON(needs.matrix.outputs.matrix) }}
    steps:
      - name: Set up PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ matrix.setup.php.version }}
          extensions: ${{ matrix.setup.php.extensions }}
        #ini-values: xdebug.mode="coverage"

      - uses: actions/checkout@v3

      - name: Set up MySQL
        if: ${{ inputs.use_db == true }}
        run: |
          sudo systemctl start mysql.service
          mysql -uroot -proot -h127.0.0.1 -e 'CREATE DATABASE phpunit;'

      - name: Import database dump
        if: ${{ inputs.use_db == true }}
        uses: uniquesca/continuous-integration/mysql-import@main
        with:
          dump_file_path: ${{ inputs.db_dump_file }}
          db_name: 'phpunit'

      - name: Cache Composer dependencies
        id: cache-composer
        uses: actions/cache@v3
        with:
          path: |
            vendor
          key: ${{ runner.os }}-${{ matrix.setup.php.version }}-composer-ci-qa-checks-${{ hashFiles('composer.json,composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.setup.php.version }}-composer-

      - name: Install Composer dependencies
        if: steps.cache-composer.outputs.cache-hit != 'true'
        run: |
          php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
          php composer-setup.php
          php -r "unlink('composer-setup.php');"
          php composer.phar config --auth github-oauth.github.com ${{ secrets.UNIQUES_GITHUB_ACCESS_TOKEN }}
          php composer.phar install
      
      - name: Prepare PHPUnit config
        run: |
          if [ -f "phpunit.xml.dist" ]; then
            cp phpunit.xml.dist phpunit.xml
          fi
        
          if [ -f "phpunit.xml" ]; then
            sed -i 's/name="db_username" value=""/name="db_username" value="root"/' phpunit.xml
            sed -i 's/name="db_password" value=""/name="db_password" value="root"/' phpunit.xml
            sed -i 's/name="db_name" value=""/name="db_name" value="phpunit"/' phpunit.xml
          fi
          
      - name: Run PHPUnit
        run: |
          if [ -f "phpunit.xml" ]; then
            ./vendor/bin/phpunit --configuration phpunit.xml
            echo "phpunit_executed=true" >> $GITHUB_ENV
          else
            echo "No PHPUnit configuration file found, skipping tests."
          fi
      
      - name: Generate coverage badge
        if: ${{ env.phpunit_executed == 'true' && github.event_name == 'pull_request' && inputs.generate_coverage_badge == true }}
        uses: timkrase/phpunit-coverage-badge@v1.2.1
        with:
          coverage_badge_path: ${{ inputs.coverage_badge_file }}
          push_badge: true
          repo_token: ${{ secrets.UNIQUES_GITHUB_ACCESS_TOKEN }}

      - name: Run PHP Codesniffer
        run: |
          if [ -f "phpcs.xml" ]; then
            ./vendor/bin/phpcs
          else
            echo "No PHP_Codesniffer configuration file found, skipping code check."
          fi

      - name: Run Psalm
        run: |
          if [ -f "psalm.xml" ]; then
            ./vendor/bin/psalm --show-info=true
          else
            echo "No Psalm configuration file found, skipping code check."
          fi

      - name: Remove execute
        run: |
          chmod -x test.sh    
          ls -al

      - name: Check execution bits
        if: inputs.exec_bit_check == true
        run: |
          CHECK_PASSED=true
          
          FOLDERS="${{ inputs.exec_bit_check_paths }}"
          
          # Adding comma at the beginning and the end
          # FOLDERS=",$FOLDERS,"
          
          # Remove double commas
          # FOLDERS=${FOLDERS//,,/,}
          
          # Search in root if ,., is specified
          if [[ "$FOLDERS" == *,.,* ]]; then
            SEARCH_IN_ROOT=true
            # Replace ,., with comma
            FOLDERS=${FOLDERS//,.,/,}
          else
            SEARCH_IN_ROOT=false
          fi
          
          # Replace slashes with escaped slashes
          FOLDERS=${FOLDERS//\//\\/}
          
          # Remove the first and the last comma
          FOLDERS=${FOLDERS:1:-1}
          
          EXTENSIONS="${{ inputs.exec_bit_check_extensions }}"
          
          # Adding comma at the beginning and the end
          EXTENSIONS=",$EXTENSIONS,"
          
          # Remove double commas
          EXTENSIONS=${EXTENSIONS//,,/,}
          
          # Replace slashes with escaped slashes
          EXTENSIONS=${EXTENSIONS//\//\\/}
          
          # Remove the first and the last comma
          EXTENSIONS=${EXTENSIONS:1:-1}
          
          if [ -z "$FOLDERS" ]; then
            # No folders specified
            FOLDERS=".*"
          else
            # Adding slash for the last folder
            FOLDERS="$FOLDERS\/"
          fi
          
          if [ -z "$EXTENSIONS" ]; then
            # No extensions specified, looking for all
            EXTENSIONS=".*"
          fi
          
          REGEX="\.\/($FOLDERS).*\.($EXTENSIONS)"
          
          if [ $SEARCH_IN_ROOT == true ]; then
            REGEX="$REGEX|\.\/[^\/]*(sh)"
          fi
          
          echo "$REGEX"
          
          find . -type f -regextype posix-extended -regex "$REGEX" | while read file; do
            if [ ! -x "$file" ]; then
              echo "$file is not executable"
              CHECK_PASSED=false
            fi
          done
          
          if $CHECK_PASSED ; then
            exit 1
          fi
        shell: bash
